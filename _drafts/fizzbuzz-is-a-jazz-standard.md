---
title: FizzBuzz is a Jazz Standard
layout: post
---


[Jeff Atwood](https://twitter.com/codinghorror), of [Coding
Horror](https://blog.codinghorror.com/) fame, wrote a blogpost called "[Why
Can't Programmers..
Program?](https://blog.codinghorror.com/why-cant-programmers-program/)", by a
happy coincidence nearly exactly 10 years ago.

Central to the post is the assertion that candidates for development jobs
should be initially screened on tasks that any remotely experienced programmer
might (many would say should) consider low hanging fruit, the canonical example
offered being "FizzBuzz."

I think that the specification for the problem is pretty universally known
at this point, mostly due to the linked post above, but it's short and simple
enough to allow a quick repeat here:

> Print the numbers 1 to 100, replacing multiples of 3 with "Fizz",
> multiples of 5 with "Buzz, and multiples of both 3 and 5 with "FizzBuzz."

I've long been fascinated by this post, having read it very early on in
learning to program myself, and coming away heartened about my chances of being
"up to snuff" after solving FizzBuzz over beers one night while exploring the
idea of a career change with a programmer friend.

At the time, I was incredulous that that was all it might take to prove a
minimal competence. Jeff does a fine job extolling the efficacy of this level
of screening and discussing both why it might be necessary and also why it
totally shouldn't be necessary. It's worth a read if you haven't seen that post
before. I'm not entirely on board with the
[essentialism](https://blog.codinghorror.com/separating-programming-sheep-from-non-programming-goats/)
being implied, but there's definitely not nothing to the main point.

I'm more interested, though, in the follow up. The very next day, Jeff published a post called
[FizzBuzz: the Programmer's Stairway to
Heaven](https://blog.codinghorror.com/fizzbuzz-the-programmers-stairway-to-heaven/).

> Evidently writing about the FizzBuzz problem on a programming blog results in a
> nigh-irresistible urge to code up a solution. The comments here, on Digg, and
> on Reddit – nearly a thousand in total – are filled with hastily coded
> solutions to FizzBuzz. Developers are nothing if not compulsive problem
> solvers.

Indeed. There are _so many_ solutions, in all manner of languages. They mostly
look the same because of course they do- it is, after all, just FizzBuzz, ffs, right?
There is a spin off Discourse thread called [FizzBuzz Solution
Dumping
Ground](https://discourse.codinghorror.com/t/fizzbuzz-solution-dumping-ground/1752)
in which there are currently 262 posts. Some of them seem to bespeak of some [pretty deep
insecurities](https://discourse.codinghorror.com/t/fizzbuzz-the-programmers-stairway-to-heaven/611/3),
some of them carry a light stink of what you might call '[smug
asshole](https://discourse.codinghorror.com/t/fizzbuzz-solution-dumping-ground/1752/73)',
even while kowtowing to the snipe hunt. The most recent post is from March 6, 2017. An
incredible ten whole years of FizzBuzz.

It _is_ a little weird, really... why _do_ so many people respond to the post
as if it's a challenge?

Programming as a craft, as an aesthetic discipline.
--------------------------------------------------

I came across a
[Longfellow](https://en.wikipedia.org/wiki/Henry_Wadsworth_Longfellow) verse
today in a [book](https://www.stoa.org.uk/topics/bullshit/pdf/on-bullshit.pdf)
I was leafing through...

```
In the elder days of art
Builders wrought with greatest care
Each minute and unseen part
For the Gods are everywhere.
```

The author quotes the verse and goes on:

> The point of these lines is clear. In the old days, craftsmen did not cut
> corners.  They worked carefully, and they took care with every aspect of their
> work. Every part of the product was considered, and each was designed and made
> to be exactly as it should be. These craftsmen did not relax their thoughtful
> self-discipline even with respect to features of their work which would
> ordinarily not be visible.  Although no one would notice if those features were
> not quite right, the craftsmen would be bothered by their consciences


Improvisation and Levity
-----------------------

Jazz is an old form, now, or at least it is heading there. [The Great American
Songbook](https://en.wikipedia.org/wiki/Great_American_Songbook) still has
_some_ room for additions, but rarely accepts them, and it is generally thought
of as being canonical, and at this point, historical.

These capital-S Standards are standards because they are well known, having originally
come from the pop music of the day. As jazz tunes, they serve as
improvisational vehicles, providing the structure and outline inside of which
an improvising musician can play extemporaneously. They remain standards in that
capacity by serving as a common repertoire between jazz musicians, regardless
of their differing backgrounds or generations or usually even jazz styles.

This type of lyric standard is just one type of jazz music, of course. We learn the
melody, it's easy, it's hummable, it comes out _kind of_ the same way each
time. The melodies are [poppy](https://www.youtube.com/watch?v=4P0hG3sD0-E),
[memorable](https://www.youtube.com/watch?v=CJTMZlRrtlE), and in many cases
quite simple, in contrast to the often frenetic
[bebop](https://www.youtube.com/watch?v=02apSoxB7B4) standards, or [modal
tunes](https://www.youtube.com/watch?v=03juO5oS2gg), or ... TODO more maybe latin big band, fusion...

But lyric standards like the ones in the Great American songbook provide a
template for the whole endeavor, a sort of blueprint for how to improvise over
_any_ tune. They're often used as [pedagogical
tools](https://www.youtube.com/watch?v=e3vL8guiFFM&list=RDe3vL8guiFFM#t=7) and
as some of the [first songs](https://www.youtube.com/watch?v=8CUEl0TLem0) young
musicians become acquainted with, while still remaining perennial set list
favorites for [musicians](https://www.youtube.com/watch?v=6aigTR-riJc) of the
[highest caliber](https://www.youtube.com/watch?v=u37RF5xKNq8).

A great improvisation will not just be riffs over the chord changes. The real
goal is to move and flow with the implicit melodic outline, following the
contours and implying the structure of the melody while playing inside of and
around the harmony. [Sonny
Rollins](http://jazzstudiesonline.org/files/jso/resources/pdf/SonnyRollinsAndChallengeOfThematicImprov.pdf)
was a master of this type of thematic improvisation,


Here's Sonny on one of his more famous tunes, 'St. Thomas', on a live TV
performance:

https://www.youtube.com/watch?v=v4DTR0I7xhA

You can hear the basic building blocks in the statement of the song, Sonny builds up a solo from there.

Here's guitarist Gilad Hekselman demonstrating this concept in a workshop over
the tune "[It could happen to
you](https://www.youtube.com/watch?v=WfGcJ-0Yr84)" ... listen to how he builds
up a vocabulary that seems to belong just to this tune over the course of a few
choruses, each one getting a little bit further afield but maintaining the
central cohesiveness of the overarching motive:

https://youtu.be/jTg3VV5v-jM?t=1m16s

Listen to how he bobs and weaves around the structure of the song but is always
hinting back at the melody, maintaining that thread, reinforcing that shape.

The 'standard' way to play standards is to play the melody first (the 'head')
and then to improvise over the form of the song, possibly taking turns, and
then to end the tune by playing the 'head out', recapitulating the melody a
final time. But it doesn't necessarily have to be that way. One of my favorite
records is from Lee Konitz, recorded in 1961, called "Motion." Lee's from a
different school, a little more pomo, a little deconstructive. Even back then
he was just launching right into the improvisation, as if to say "alright
alright we all know this tune lets get on with it."

[Lee Konitz](https://www.youtube.com/watch?v=A5tT00jXEkU)

He actually doesn't even play the melody _at all_ until the very very end- practically at the
last second... starting at about 7:39, and even then it's pretty sparse- just one
A section and a few flutters and that's it.

I'll permit that this is pretty inside baseball and winky. Not everyone
listening knows the song, and certainly not everyone can hear the changes
happening underneath the improvisation and place the song just by that. But
it's also really cool!

Here's a more conventional version of that tune, melody clearly stated and even
arranged:

[Cannonball Adderly](https://www.youtube.com/watch?v=ySrjb-rFvEQ)


I photographed Lee Konitz in his apartment once for a magazine article. When we
got there we asked him what he had been practicing that day. "[All the things
you are](https://www.youtube.com/watch?v=PhBQd2VMWzA)" he said. He's been
playing that old song for
[decades](https://www.youtube.com/watch?v=FGytJW8vpRA), and he's [still playing
it](https://www.youtube.com/watch?v=ptK2C5G9ruU).

https://www.flickr.com/photos/monkeywithamirror/5759834284/in/photolist-9LYE4E

Fizzbuzz is _not_ a hard problem. It's an _easy_ problem. You have to know what
you're doing to program fizzbuzz in the same way you have to know what you're
doing to program anything... you need to know your tools and have a functional
mental model of programming and understand some rudimentary control flow
concepts. If fizzbuzz as a task is testing anything at all, it's really testing
_that_, and that's fine. Fizzbuzz is easy, sure, but it's not entirely dissimilar to workaday
programming tickets I might see from time to time. "Filter out users who aren't
signed in and redirect them to the login page" maybe, or "catch these two
exceptions for special treatment and disregard any others thrown," or any
number of other things. These types of tickets also aren't necessarily
_difficult_, but they're certainly part of my day to day life.

But I think there's more to it than that.

Fizzbuzz is a melody; it's a short and easy to remember little song. Much like a
simple tune can become an ideal vehicle for improvisation and caprice precisely
_because_ it's a simple tune, and not in spite of it, there is something about
the structure and simplicity of FizzBuzz that gets you thinking... what if I
did it like this? or that? or I wonder if I could do it with that other thing
hmm....

I'll admit, now, that despite my waxing on _why_ so many people responded to that
post with fizzbuzz solutions, [I couldn't resist it any better than they
could](https://discourse.codinghorror.com/t/fizzbuzz-solution-dumping-ground/1752/191).
(Here's [an explanatory post](http://blog.jfo.click/fizzbuzz-in-brainfuck-part-one/).)

The Great Programmer Song Book
------------------------------

Fizzbuzz isn't alone in this fakebook, far from it. It belongs to a subclass of
programming problems that have that, for lack of a better word, 'poppiness' to
them. They may be but don't have to be easy to complete, but
memorable for sure... easy to remember, easy to 'hum.'

[The Recurse Center](https://www.recurse.com/) uses Fizzbuzz during its
prelimenary [application process](https://www.recurse.com/apply) both as a
screening question and as an opportunity for displaying creativity, although they've
changed the terms to 'CracklePop' to thwart would be plagiarizers (a wrinkle
that lost me a weekend when I had to refactor my brainfuck version to print out
the new copy...)

Have you seen [FizzBuzz Enterprise
Edition](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition)
from Enterprise Quality Coding? It's a hoot. There are 99 files in that repo,
and they're [still receiving pull
requests](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition/pulls).
And yeah, last time I checked at least, it ran.

Another problem like this is the eight queens problem:

> Place eight queens on an 8 by 8 chessboard so that no two queens threaten each other.

There are 92 and only 92 ways to do this. The problem could be "find one
solution" or it could be "find them all" or it could be "find all solutions
that are not rotations of any previously found solutions." It could be
generalized to be the "n-queens" problem...

> Place _n_ queens on an x by y chessboard so that no two queens threaten each other.

You could allow the chess board could be a non-rectangular shape, or it could
be 3 dimensions, or it could be `n` dimensions. There are _tons_ of ways to
play through this song form, but the simple melody is always there.

[Here's a solution by David
Dalrymple](http://davidad.github.io/blog/2014/02/25/overkilling-the-8-queens-problem/)
written directly in x86 Assembly that may very well run faster than any other
solution ever.

[Here's one by Andree Monette](http://acmonette.com/here-there-be-pydras.html)
that uses Python's garbage collector as a computational stack and produces the
correct value on exit of the program.

There are many ways to solve it. It's naturally a recursive problem, but
you could solve it iteratively if you wanted to.

Are these things important? Are they necessary? No, of course not. Programming
can be aesthetic, and it can be playful, and it can be improvisatory too.

How about Conway's Game of Life? Here's a demonstration of an implementation of
that in [APL](http://www.youtube.com/watch?v=a9xAKttWgP4). I must have watched
that video a dozen times and it still melts my brain.

The change counting problem from [Structure and Interpretation of Computer
Programs](https://mitpress.mit.edu/sicp/full-text/sicp/book/node16.html) is a
good candidate, as is the related [n'th
stair](http://www.geeksforgeeks.org/count-ways-reach-nth-stair/) problem. There
are a lot of them!

I'd like someday to compile a set of some of these "standards." The point is
not the be a challenge, _necessarily_, but to spark ideas, to offer a canvas to
play on, a song to play through.

I'll end with my [own
version](https://jefffowler.bandcamp.com/track/bye-bye-blackbird) of an [old
song](https://www.youtube.com/watch?v=qhdHky_zoyQ).
